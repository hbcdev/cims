*!*	CusrorAdapter Class Generator for Visual FoxPro 8
*!*	
*!*	This class is designed to connect to a DBC, Oracle
*!*	or SQL Server, retrieve all tables in that database,
*!*	and create a CursorAdapter subclass for each table.
*!*	This class generates the code that is needed at runtime
*!*	to populate the properties in each CA in order for VFP
*!*	to auto-generate the Insert, Update, Delete SQL. This
*!*	code is then written into the AUTOOPEN and INIT methods
*!*	of each CA subclass. I will be adding capability where
*!*	the InsertCmd, UpdateCmd, and DeleteCmd properties will
*!*	also be populated along with a customer property to
*!*	specify which form of updating is to be used.
*!*	
*!*	The first step done by the builder is the creation of
*!*	a Class Library [VCX] with a CursorAdapter baseclass.
*!*	Then, all the Table-specific CursorAdapters are created
*!*	as sub-classes of the CA baseclass. This allows you to
*!*	set "common" properties at the baseclass level like a
*!*	DataSource [connection handle] for example.
*!*	
*!*	Please keep in mind this is a design time UTILITY and
*!*	is not intended to be "pretty" with respect to the UI.
*!*	However, it does its intended job quite nicely.
*!*	
*!*	If you have any questions, suggestions, bug reports, please
*!*	post a new message to me on the UT -- http://ww.UniversalThread.com
*!*	
*!*	Thanks,
*!*	
*!*	Mark McCasland
*!*	
*!*	DO NOT COMMENT THE #DEFINE COMMANDS BELOW.
#DEFINE VFP_TAB [	]
#DEFINE VFP_CRLF CHR(13) + CHR(10)

*!*	The following is TEST/DEMO CODE to show the functionality of this class.
*!*	You need to modify it before you run it for Oracle and SQL Server databases.
*!*	You can run it as is for a VFP database.
*!*	
CLEAR
LOCAL lnTest
PRIVATE pcClassLib, poCA
IF NOT DIRECTORY(".\Classes")
	MD .\Classes
ENDIF
lnTest = 3
pcClassLib = [.\Classes\_CA_NW]
poCA = CREATEOBJECT('CABuilder')
poCA.cClassLib = FULLPATH(pcClassLib)

*!*	For SQL Server and Oracle, you should specify login parms
DO CASE
	CASE lnTest = 1
		SQLServerTest()
	CASE lnTest = 2
		OracleTest()
	CASE lnTest = 3
		NativeTest()
ENDCASE

CheckErrors()
pcClassLib = FORCEEXT(poCA.cClassLib, 'VCX')
poCA.Release()
IF FILE(pcClassLib)
	DO (_browser) WITH pcClassLib
ENDIF
RETURN

PROCEDURE SQLServerTest
	poCA.cServer = [localhost]
	poCA.cDatabase = [Northwind]
	poCA.lOracle = .f.
	poCA.Build()
ENDPROC
PROCEDURE OracleTest
	poCA.cUserID = [MyUID]
	poCA.cPassword = [MyPWD]
	poCA.cServer = [local]
	poCA.Build()
ENDPROC
PROCEDURE NativeTest
	poCA.cSourceType = [NATIVE]
	poCA.Build()
ENDPROC
PROCEDURE CheckErrors
	CLEAR
	LOCAL lcTable, lnI
	IF NOT EMPTY(poCA.aBadTables[1])
		?
		? [Unprocessed Tables:]
		?
		FOR EACH lcTable IN poCA.aBadTables
			? lcTable
		ENDFOR
	ENDIF
	IF poCA.lError
		?
		? [Error:], poCA.cErrorMessage
		IF poCA.aErrorInfo[1] > 0
			?
			FOR lnI = 1 TO ALEN(poCA.aErrorInfo)
				? poCA.aErrorInfo[lnI]
			ENDFOR
		ENDIF
	ENDIF
ENDPROC


DEFINE CLASS CABuilder AS Session

	nConnectHandle = 0
	PROTECTED lDisconnect  && set to true if the connection is created by this class.
	PROTECTED nOldDispLogin
	nOldDispLogin = 1
	PROTECTED nOldBuffering
	nOldBuffering = 1

	cUserID = []
	cPassword = []
	cServer = []
	cDatabase = []  && SQL Server database to connect to.
	lOracle = .T.   && set to .F. if SQL Server

	cCAPrefix = [_CA_]	&& Prefix to add to the name of each CA class created
	cClassLib = []		&& Only used if cClassType is [VCX]
	cClassType = [VCX]  && or [PRG]

	cSourceType = [ODBC]  && or ADO or NATIVE

	lError = .F.
	cErrorMessage = []
	DIMENSION aErrorInfo[1]
	DIMENSION aBadTables[1]

	PROTECTED cSelectParms
	cSelectParms = []
	PROTECTED lWriteSchema	&& Set by GetCursorSchema method
	lWriteSchema = .f.

	lWrapInit = .t.			&& wrap Init method code generated by this builder
							&& with code that would be generated by the VFP8 CA Builder

	PROCEDURE Build
		LOCAL llRetVal
		llRetVal = THIS.BuildAdapters()
		RETURN (llRetVal AND NOT THIS.lError)
	ENDPROC
	PROCEDURE ResetErrorInfo
		THIS.lError = .f.
		THIS.cErrorMessage = []
		DIMENSION THIS.aErrorInfo[1]
		THIS.aErrorInfo[1] = 0
	ENDPROC
	PROCEDURE Release
		RELEASE THIS
	ENDPROC
	PROTECTED PROCEDURE Init
		SET TALK OFF
		SET DELETED ON
		SET EXCLUSIVE OFF
		THIS.nOldDispLogin = SQLGETPROP(0, "DispLogin")
		SQLSETPROP(0, "DispLogin", 1)
		THIS.nOldBuffering = CURSORGETPROP("Buffering", 0)
		CURSORSETPROP("Buffering", 1, 0)
		THIS.aBadTables = []
		THIS.ResetErrorInfo()
	ENDPROC
	PROTECTED PROCEDURE Destroy
		SQLSETPROP(0, "DispLogin", THIS.nOldDispLogin)
		CURSORSETPROP("Buffering", THIS.nOldBuffering, 0)
		IF THIS.lDisconnect
			SQLDISCONNECT(THIS.nConnectHandle)
		ENDIF
	ENDPROC
	PROTECTED PROCEDURE Error(nError, cMethod, nLine)
		THIS.lError = .t.
		THIS.cErrorMessage = [Error: ] + TRANSFORM(nError) + [   Method: ] + cMethod + [   Line: ] + TRANSFORM(nLine)
		AERROR(THIS.aErrorInfo)
	ENDPROC
	PROTECTED PROCEDURE SetError
		LPARAMETERS tcMessage, tlArray
		THIS.lError = .t.
		THIS.cErrorMessage = tcMessage
		IF VARTYPE(tlArray) = [L] AND tlArray
			AERROR(THIS.aErrorInfo)
		ENDIF
	ENDPROC
	PROTECTED PROCEDURE AddBadTable
		LPARAMETERS tcTable
		IF EMPTY(THIS.aBadTables[1])
			THIS.aBadTables[1] = tcTable
			RETURN
		ENDIF
		LOCAL lnLen
		lnLen = ALEN(THIS.aBadTables, 1) + 1
		DIMENSION THIS.aBadTables(lnLen)
		THIS.aBadTables[lnLen] = tcTable
	ENDPROC
	PROTECTED PROCEDURE BuildAdapters
		IF NOT THIS.Cr8_Connection() OR THIS.lError
			RETURN .f.
		ENDIF
		IF NOT THIS.Cr8_ClassLib() OR THIS.lError
			RETURN .f.
		ENDIF
		IF NOT THIS.GetTables() OR THIS.lError
			RETURN .f.
		ENDIF
		IF NOT THIS.GetKeyFields() OR THIS.lError
			RETURN .f.
		ENDIF
		IF NOT THIS.Cr8_Classes() OR THIS.lError
			RETURN .f.
		ENDIF
	ENDPROC
	PROTECTED PROCEDURE Cr8_Connection
		IF THIS.nConnectHandle > 0
			RETURN .T.
		ENDIF
		IF THIS.cSourceType = [NATIVE]
			LOCAL llRetVal
			llRetVal = THIS.OpenDatabase()
			RETURN llRetVal
		ENDIF
		LOCAL lcString
		DO CASE
			CASE THIS.cSourceType = [ODBC]
				lcString = [Driver=Microsoft ODBC for Oracle;]
				IF NOT THIS.lOracle
					lcString = [Driver=SQL Server;Database=] + THIS.cDatabase + [;]
				ENDIF
				lcString = lcString + [UID=] + THIS.cUserID + [;PWD=] ;
						 + THIS.cPassword + [;Server=] + THIS.cServer + [;]
			CASE THIS.cSourceType = [NATIVE]
				lcString = [Driver=Microsoft Visual FoxPro Driver;]
			OTHERWISE
				RETURN .f.  && ADO to be added later
		ENDCASE
		THIS.nConnectHandle = SQLSTRINGCONNECT(lcString)
		IF THIS.nConnectHandle > 0
			THIS.lDisconnect = .T.
		ELSE
			THIS.SetError([Could not connect to server.], .t.)
		ENDIF
		RETURN (THIS.nConnectHandle > 0)
	ENDPROC
	PROTECTED PROCEDURE OpenDatabase
		LOCAL lcDBC
		lcDBC = GETFILE("DBC", "Database", "Open", 1, "Select Database to Open")
		IF EMPTY(lcDBC) OR NOT FILE(lcDBC)
			THIS.SetError([You must specify a valid DBC to open])
			RETURN .f.
		ENDIF
		OPEN DATABASE (lcDBC)
		SET DATABASE TO (lcDBC)
		THIS.nConnectHandle = 999
	ENDPROC
	PROTECTED PROCEDURE Cr8_ClassLib
		IF THIS.cClassType = [PRG]
			RETURN .t.
		ENDIF
		LOCAL lcLib
		lcLib = THIS.cClassLib
		IF EMPTY(lcLib) OR FILE(FORCEEXT(lcLib, [VCX]))
			lcLib = GETFILE([VCX], [ClassLib Name], [OK], 0, [Specify a NEW ClassLib Name for the CA Classes])
			IF NOT EMPTY(lcLib)
				lcLib = FORCEEXT(lcLib, [VCX])
			ENDIF
			IF EMPTY(lcLib) OR UPPER(lcLib) == [UNTITLED.VCX] OR FILE(lcLib)
				THIS.SetError([You must provide a valid name for a ClassLib that does not already exist.])
				RETURN .f.
			ENDIF
			THIS.cClassLib = lcLib
		ENDIF
		lcLib = THIS.cClassLib
		LOCAL laClass[1], loClass
		CREATE CLASSLIB (lcLib)
		CREATE CLASS _CABase AS CursorAdapter OF (lcLib) NOWAIT
		ASELOBJ(laClass, 1)
		loClass = laClass[1]
		WITH loClass
			.Comment = [Cursor Adapter Baseclass]
			.BufferModeOverride = 5
			.DataSourceType = [ODBC]
			.WhereType = 1
		ENDWITH
		loClass = .null.
		KEYBOARD 'Y' CLEAR
		RELEASE WINDOW 'Class Designer - ' + LOWER(lcLib) + ' (' + LOWER(lcClass) + ')'
	ENDPROC
	PROTECTED PROCEDURE GetTables
		IF THIS.cSourceType = [NATIVE]
			LOCAL llRetVal
			llRetVal = THIS.GetNativeTables()
			RETURN llRetVal
		ENDIF
		LOCAL lnRetVal, lcID
		lnRetVal = SQLTABLES(THIS.nConnectHandle, [TABLE], [crsTables])
		IF lnRetVal < 0 OR NOT USED('crsTables')
			THIS.SetError([Error retrieving list of tables from the database.])
			RETURN .F.
		ENDIF
		lcID = THIS.cUserID
		SELECT crsTables
		IF THIS.lOracle
			SET FILTER TO Table_Owner = '&lcID'
		ENDIF
		LOCATE
		IF EOF('crsTables')
			THIS.SetError([No tables found for specified User/Database.])
			RETURN .F.
		ENDIF
	ENDPROC
	PROTECTED PROCEDURE GetKeyFields
		IF THIS.cSourceType = [NATIVE]
			LOCAL llRetVal
			llRetVal = THIS.GetNativePKs()
			RETURN llRetVal
		ENDIF
		LOCAL lnRetVal, lcSQL
		IF THIS.lOracle
			TEXT TO lcSQL NOSHOW PRETEXT 3
				SELECT
					TC.Constraint_Type, 
					IC.Index_Name,
					IC.Table_Name,
					IC.Column_Name
				FROM
					User_Constraints TC, User_Ind_Columns IC
				WHERE IC.Index_Name = TC.Constraint_Name
					and TC.Constraint_Type = 'P'
				ORDER BY IC.Table_Name
			ENDTEXT
		ELSE
			TEXT TO lcSQL NOSHOW PRETEXT 3
				SELECT 
					TC.Constraint_Type,
					TC.Constraint_Name Index_Name,
					TC.Table_Name,
					CCU.Column_Name
				FROM Information_Schema.Table_Constraints TC
					JOIN Information_Schema.Constraint_Column_Usage CCU
						ON TC.Constraint_Name = CCU.Constraint_Name
				WHERE Constraint_Type = 'PRIMARY KEY'
				ORDER BY TC.Table_Name
			ENDTEXT
		ENDIF
		lnRetVal = SQLEXEC(THIS.nConnectHandle, lcSQL, [crsPKs])
		RETURN (lnRetVal > 0)
	ENDPROC
	PROTECTED PROCEDURE GetNativeTables
		SELECT 0
		CREATE CURSOR crsTables (Table_Name C(60))
		LOCAL lnRetVal, lcTable, laTables[1]
		IF NOT DBUSED(DBC())
			RETURN .f.
		ENDIF
		lnRetVal = ADBOBJECTS(laTables,"TABLE")
		FOR EACH lcTable IN laTables
			INSERT INTO crsTables VALUES ( lcTable )
		ENDFOR
	ENDPROC
	PROTECTED PROCEDURE GetNativePKs
		SELECT 0
		CREATE CURSOR crsPKs (Constraint_Type C(1), Index_Name C(30), Table_Name C(60), Column_Name C(60))
		LOCAL lnRetVal, lnI, lcTable, lcField, lcTag, lcKey, lcExpr, laTables[1], laFields[1], lcString
		lnRetVal = ADBOBJECTS(laTables,"TABLE")
		FOR EACH lcTable IN laTables
			lcTag = DBGETPROP(lcTable,"TABLE","PrimaryKey")
			IF EMPTY(lcTag)
				LOOP
			ENDIF
			SELECT 0
			USE (lcTable)
			lcKey = KEY(TAGNO(lcTag))
			lcExpr = lcKey
			USE
			IF EMPTY(STREXTRACT(lcKey, "(", ")", 1))
				INSERT INTO crsPKs VALUES ('P', lcTag, lcTable, lcExpr)
				LOOP
			ENDIF
			lcKey = [+] + lcKey + [+]
			lnI = 1
			laFields = []
			DO WHILE NOT EMPTY(lcKey)
				lcString = STREXTRACT(lcKey, "+", "+", 1)
				lcKey = STRTRAN(lcKey, "+" + lcString + "+", [])
				IF NOT EMPTY(lcKey)
					lcKey = "+" + lcKey
				ENDIF
				IF NOT EMPTY(lcString)
					lcString = THIS.GetFieldName(lcString)
					DIMENSION laFields[lnI]
					laFields[lnI] = lcString
				ELSE
					EXIT
				ENDIF
				lnI = lnI + 1
			ENDDO
			FOR EACH lcField IN laFields
				INSERT INTO crsPKs VALUES ('P', lcTag, lcTable, lcField)
			ENDFOR
		ENDFOR
		SELECT crsPKs
	ENDPROC
	PROTECTED PROCEDURE GetFieldName
		LPARAMETERS tcString
		LOCAL lcName, lnI, lnAt
		lnI = OCCURS("(", tcString)
		tcString = STREXTRACT(tcString, "(", ")", lnI)
		lnAt = AT(",", tcString)
		IF lnAt > 1
			tcString = SUBSTR(tcString, 1, lnAt - 1)
		ENDIF
		RETURN ALLTRIM(tcString)
	ENDPROC
	PROTECTED PROCEDURE Cr8_Classes
		LOCAL lcTable, lcSQL, lnRetVal
		SELECT crsTables
		SCAN
			lcTable = TRIM(crsTables.Table_Name)
			IF THIS.cSourceType = [NATIVE]
				select * from (lcTable) where 1=2 INTO CURSOR crsData NOFILTER
				lnRetVal = 1
			ELSE
				lcSQL = [select * from ] + lcTable + [ where 1=2]
				lnRetVal = SQLEXEC(THIS.nConnectHandle, lcSQL, [crsData])
			ENDIF
			IF lnRetVal < 0 OR NOT USED('crsData')
				IF USED('crsData')
					USE IN crsData
				ENDIF
				THIS.AddBadTable(lcTable)
				LOOP
			ENDIF
			SELECT crsData
			THIS.AddClass(lcTable)
			USE IN crsData
		ENDSCAN
	ENDPROC
	PROTECTED PROCEDURE AddClass
		LPARAMETERS tcTable
		LOCAL lnRetVal, lnI, laFields[1], lcFName, lcSchema, lcNameList, lcFieldList, lcFuncList, lcKeyFields
		lcSchema = []
		lcNameList  = []
		lcFieldList = []
		lcFuncList  = []
		lcKeyFields = []
		lnRetVal = AFIELDS(laFields, 'crsData')
		FOR lnI = 1 TO lnRetVal
			lcFName = laFields[lnI, 1]
			IF NOT EMPTY(lcNameList)
				lcNameList  = lcNameList  + [, ] + VFP_CRLF + VFP_TAB
				lcFieldList = lcFieldList + [, ] + VFP_CRLF + VFP_TAB
			ELSE
				lcNameList  = [TEXT TO lcNameList  NOSHOW] + VFP_CRLF + VFP_TAB
				lcFieldList = [TEXT TO lcFieldList NOSHOW] + VFP_CRLF + VFP_TAB
				lcSchema    = [TEXT TO lcSchema    NOSHOW] + VFP_CRLF + VFP_TAB
			ENDIF
			lcNameList  = lcNameList  + lcFName + [ ] + PROPER(tcTable) + [.] + lcFName
			lcFieldList = lcFieldList + lcFName
			IF laFields[lnI, 2] = [C]
				IF NOT EMPTY(lcFuncList)
					lcFuncList = lcFuncList + [, ] + VFP_CRLF + VFP_TAB
				ELSE
					lcFuncList = [TEXT TO lcFuncList  NOSHOW] + VFP_CRLF + VFP_TAB
				ENDIF
				lcFuncList  = lcFuncList + lcFName + [ RTRIM]
			ENDIF
		NEXT
		IF NOT EMPTY(lcNameList)
			lcNameList = lcNameList + VFP_CRLF + [ENDTEXT] + VFP_CRLF ;
				+ "lcNameList = CHRTRAN(STRTRAN(lcNameList, VFP_TAB, []), VFP_CRLF, [ ])"
		ENDIF
		IF NOT EMPTY(lcFieldList)
			lcFieldList = lcFieldList + VFP_CRLF + [ENDTEXT] + VFP_CRLF ;
				+ "lcFieldList = CHRTRAN(STRTRAN(lcFieldList, VFP_TAB, []), VFP_CRLF, [ ])"
		ENDIF
		IF NOT EMPTY(lcFuncList)
			lcFuncList = lcFuncList + VFP_CRLF + [ENDTEXT] + VFP_CRLF ;
				+ "lcFuncList = CHRTRAN(STRTRAN(lcFuncList, VFP_TAB, []), VFP_CRLF, [ ])"
		ENDIF
		lcKeyFields = THIS.GetPKList(tcTable)
		lcSchema = THIS.GetCursorSchema()
		lcClass = THIS.cCAPrefix + LOWER(tcTable)
		lcLib = THIS.cClassLib
		LOCAL laClass[1], loClass, lcInit, lcCAInit
		lcCAInit = "#DEFINE VFP_" + "TAB [	]" + VFP_CRLF ;
				 + "#DEFINE VFP_" + "CRLF CHR(13) + CHR(10)" + VFP_CRLF + VFP_CRLF ;
				 + [DODEFAULT()] + VFP_CRLF ;
				 + [LOCAL lcFieldList, lcNameList, lcFuncList] + VFP_CRLF ;
				 + [STORE '' TO lcFieldList, lcNameList, lcFuncList]
		IF THIS.lWriteSchema
			lcCAInit = lcCAInit + [, lcSchema] +  VFP_CRLF ;
				+ STRTRAN(lcSchema, [  ], [ ]) + VFP_CRLF
		ELSE
			lcCAInit = lcCAInit + VFP_CRLF
		ENDIF
		lcCAInit = lcCAInit ;
				 + STRTRAN(lcNameList, [  ], [ ]) + VFP_CRLF ;
				 + STRTRAN(lcFieldList, [  ], [ ]) + VFP_CRLF ;
				 + STRTRAN(lcFuncList, [  ], [ ]) + VFP_CRLF ;
				 + [WITH THIS] + VFP_CRLF ;
				 + [	.UpdatableFieldList = lcFieldList] + VFP_CRLF ;
				 + [	.UpdateNameList = lcNameList] + VFP_CRLF ;
				 + [	.ConversionFunc = lcFuncList] + VFP_CRLF ;
				 + [	.KeyFieldList = '] + lcKeyFields + ['] + VFP_CRLF ;
				 + [	.SelectCmd = 'select * from ] + LOWER(tcTable) + [ where ] + THIS.cSelectParms + ['] + VFP_CRLF
		IF THIS.lWriteSchema
			lcCAInit = lcCAInit ;
					 + [	.CursorSchema = lcSchema] + VFP_CRLF
		ENDIF
		lcCAInit = lcCAInit + [ENDWITH] + VFP_CRLF
		lcInit = THIS.GetInitWrapping([THIS._CA_Init()] + VFP_CRLF)
		CREATE CLASS (lcCLass) OF (lcLib) AS _CABase FROM (lcLib) NOWAIT
		ASELOBJ(laClass, 1)
		loClass = laClass[1]
		THIS.WriteAutoOpen(loClass)
		WITH loClass
			IF NOT THIS.lWriteSchema
				.CursorSchema = lcSchema
			ENDIF
			.Alias = [crs] + PROPER(tcTable)
			.Tables = PROPER(tcTable)
			.WriteMethod([Init], lcInit)
			.WriteMethod([_CA_Init], lcCAInit, .T.)
		ENDWITH
		KEYBOARD 'Y' CLEAR
		RELEASE WINDOW 'Class Designer - ' + LOWER(lcLib) + ' (' + LOWER(lcClass) + ')'
	ENDPROC
	PROTECTED PROCEDURE GetPKList
		LPARAMETERS tcTable
		LOCAL lnSelect, lcList, lcParmList
		lcList = []
		lcParmList = []
		lnSelect = SELECT()
		SELECT crsPKs
		SET FILTER TO UPPER(TRIM(Table_Name)) == UPPER(TRIM(tcTable))
		LOCATE
		SCAN
			IF NOT EMPTY(lcList)
				lcList = lcList + [, ]
				lcParmList = lcParmList + [ AND ]
			ENDIF
			lcList = lcList + ALLTRIM(crsPKs.Column_Name)
			lcParmList = lcParmList + ALLTRIM(crsPKs.Column_Name) + [ = ?p] + ALLTRIM(crsPKs.Column_Name)
		ENDSCAN
		THIS.cSelectParms = lcParmList
		SET FILTER TO 
		SELECT (lnSelect)
		RETURN lcList
	ENDPROC
	PROTECTED PROCEDURE GetCursorSchema
		LOCAL lnRetVal, laFields[1], lnI, lcSchema, lcSchema2, lcField, lcType, lnWidth, lnDec
		lcSchema = []
		lcSchema2 = []
		lnRetVal = AFIELDS(laFields, 'crsData')
		FOR lnI = 1 to lnRetVal
			lcField = laFields[lnI, 1]
			lcType  = laFields[lnI, 2]
			lnWidth = laFields[lnI, 3]
			lnDec   = laFields[lnI, 4]
			IF NOT EMPTY(lcSchema)
				lcSchema  = lcSchema + [,] + VFP_CRLF + VFP_TAB
				lcSchema2 = lcSchema2 + [,]
			ELSE
				lcSchema  = [TEXT TO lcSchema    NOSHOW] + VFP_CRLF + VFP_TAB
			ENDIF
			lcSchema  = lcSchema  + lcField + [ ]
			lcSchema2 = lcSchema2 + lcField + [ ]
			DO CASE
				CASE INLIST(lcType, [Y], [D], [T], [L], [M], [G], [I])
					lcSchema  = lcSchema  + lcType
					lcSchema2 = lcSchema2 + lcType
				CASE lcType = [C]
					lcSchema  = lcSchema  + lcType + [(] + TRANSFORM(lnWidth) + [)]
					lcSchema2 = lcSchema2 + lcType + [(] + TRANSFORM(lnWidth) + [)]
				CASE INLIST(lcType, [N], [F], [B])
					lcSchema  = lcSchema  + lcType + [(] + TRANSFORM(lnWidth) + [,] + TRANSFORM(lnDec) + [)]
					lcSchema2 = lcSchema2 + lcType + [(] + TRANSFORM(lnWidth) + [,] + TRANSFORM(lnDec) + [)]
			ENDCASE
		ENDFOR
		IF NOT EMPTY(lcSchema)
			lcSchema = lcSchema + VFP_CRLF + [ENDTEXT] + VFP_CRLF ;
				+ "lcSchema = CHRTRAN(STRTRAN(lcSchema, VFP_TAB, []), VFP_CRLF, [ ])"
		ENDIF
		THIS.lWriteSchema = .T.
		lcSchema2 = ALLTRIM(lcSchema2)
		IF LEN(lcSchema2) < 255
			THIS.lWriteSchema = .F.
			lcSchema = lcSchema2
		ENDIF
		RETURN lcSchema
	ENDPROC
	PROTECTED PROCEDURE GetInitWrapping
		LPARAMETERS tcInit
		IF EMPTY(tcInit) OR NOT THIS.lWrapInit
			RETURN tcInit
		ENDIF
		LOCAL lcNewInit
		lcNewInit = ;
				[DO CASE] + VFP_CRLF ;
			+	[	CASE NOT PEMSTATUS(THIS, '__VFPSetup', 5)] + VFP_CRLF ;
			+	[		THIS.AddProperty('__VFPSetup', 0)] + VFP_CRLF ;
			+	[	CASE THIS.__VFPSetup = 2] + VFP_CRLF ;
			+	[		THIS.__VFPSetup = 0] + VFP_CRLF ;
			+	[		RETURN] + VFP_CRLF ;
			+	[ENDCASE] + VFP_CRLF + VFP_CRLF ;
			+	tcInit + VFP_CRLF ;
			+	[IF THIS.__VFPSetup = 1] + VFP_CRLF ;
			+	[	THIS.__VFPSetup = 2] + VFP_CRLF ;
			+	[ENDIF] + VFP_CRLF
		RETURN lcNewInit
	ENDPROC
	PROTECTED PROCEDURE WriteAutoOpen
		LPARAMETERS toClass
		LOCAL lcCode
		lcCode = ;
				[*** Setup code: DO NOT REMOVE] + VFP_CRLF ;
			+	[if not pemstatus(This, '__VFPSetup', 5)] + VFP_CRLF ;
			+	[	This.AddProperty('__VFPSetup', 1)] + VFP_CRLF ;
			+	[	This.Init()] + VFP_CRLF ;
			+	[endif] + VFP_CRLF ;
			+	[*** End of Setup code: DO NOT REMOVE] + VFP_CRLF
		toClass.WriteMethod('AutoOpen', lcCode)
	ENDPROC

	*!* Protected Assign Methods

	PROTECTED PROCEDURE cUserID_Assign
		LPARAMETERS tcUser
		IF VARTYPE(tcUser) <> [C]
			THIS.SetError([Invalid datatype for ] + STRTRAN(PROGRAM(), [_ASSIGN], []) + [ property.])
			RETURN .f.
		ENDIF
		THIS.cUserID = ALLTRIM(tcUser)
	ENDPROC
	PROTECTED PROCEDURE cPassword_Assign
		LPARAMETERS tcPWD
		IF VARTYPE(tcPWD) <> [C]
			THIS.SetError([Invalid datatype for ] + STRTRAN(PROGRAM(), [_ASSIGN], []) + [ property.])
			RETURN .f.
		ENDIF
		THIS.cPassword = ALLTRIM(tcPWD)
	ENDPROC
	PROTECTED PROCEDURE cServer_Assign
		LPARAMETERS tcServer
		IF VARTYPE(tcServer) <> [C]
			THIS.SetError([Invalid datatype for ] + STRTRAN(PROGRAM(), [_ASSIGN], []) + [ property.])
			RETURN .f.
		ENDIF
		THIS.cServer = ALLTRIM(tcServer)
	ENDPROC
	PROTECTED PROCEDURE cDatabase_Assign
		LPARAMETERS tcDatabase
		IF VARTYPE(tcDatabase) <> [C]
			THIS.SetError([Invalid datatype for ] + STRTRAN(PROGRAM(), [_ASSIGN], []) + [ property.])
			RETURN .f.
		ENDIF
		THIS.cDatabase = ALLTRIM(tcDatabase)
	ENDPROC
	PROTECTED PROCEDURE cClassLib_Assign
		LPARAMETERS tcClassLib
		IF VARTYPE(tcClassLib) <> [C]
			THIS.SetError([Invalid datatype for ] + STRTRAN(PROGRAM(), [_ASSIGN], []) + [ property.])
			RETURN .f.
		ENDIF
		tcClassLib = FORCEEXT(tcClassLib, THIS.cClassType)
		tcClassLib = SUBSTR(tcClassLib, 1, RAT([.] + THIS.cClassType, tcClassLib) -1)
		THIS.cClassLib = ALLTRIM(tcClassLib)
	ENDPROC
	PROTECTED PROCEDURE cCAPrefix_Assign
		LPARAMETERS tcCAPrefix
		IF VARTYPE(tcCAPrefix) <> [C] OR EMPTY(tcCAPrefix)
			THIS.SetError([Invalid datatype for ] + STRTRAN(PROGRAM(), [_ASSIGN], []) + [ property.])
			RETURN .f.
		ENDIF
		THIS.cCAPrefix = ALLTRIM(tcCAPrefix)
	ENDPROC
	PROTECTED PROCEDURE cClassType_Assign
		LPARAMETERS tcClassType
		IF VARTYPE(tcClassType) <> [C]
			THIS.SetError([Invalid datatype for ] + STRTRAN(PROGRAM(), [_ASSIGN], []) + [ property.])
			RETURN .f.
		ENDIF
		tcClassType = UPPER(ALLTRIM(tcClassType))
		IF NOT INLIST(tcClassType, [PRG], [VCX])
			THIS.SetError([Class type for ] + STRTRAN(PROGRAM(), [_ASSIGN], []) + [ property must be PRG or VCX.])
			RETURN .f.
		ENDIF
		THIS.cClassType = ALLTRIM(tcClassType)
	ENDPROC
	PROTECTED PROCEDURE cSourceType_Assign
		LPARAMETERS tcSource
		LOCAL lcMessage
		lcMessage = [Invalid ] + STRTRAN(PROGRAM(), [_ASSIGN], []) + [ property. Must be ADO, ODBC or NATIVE.]
		IF VARTYPE(tcSource) <> [C]
			THIS.SetError([Invalid datatype for ] + STRTRAN(PROGRAM(), [_ASSIGN], []) + [ property.])
			RETURN .f.
		ENDIF
		tcSource = ALLTRIM(UPPER(tcSource))
		IF NOT INLIST(tcSource, [NATIVE], [ODBC], [ADO])
			THIS.SetError(lcMessage)
			RETURN .f.
		ENDIF
		THIS.cSourceType = tcSource
	ENDPROC
	PROTECTED PROCEDURE lWrapInit_Assign
		LPARAMETERS tlWrapInit
		IF VARTYPE(tlWrapInit) <> [L]
			THIS.SetError([Invalid datatype for ] + STRTRAN(PROGRAM(), [_ASSIGN], []) + [ property.])
			RETURN .f.
		ENDIF
		THIS.lWrapInit = tlWrapInit
	ENDPROC
	PROTECTED PROCEDURE lError_Assign
		LPARAMETERS tlError
		IF VARTYPE(tlError) <> [L]
			THIS.SetError([Invalid datatype for ] + STRTRAN(PROGRAM(), [_ASSIGN], []) + [ property.])
			RETURN .f.
		ENDIF
		THIS.lError = tlError
	ENDPROC
	PROTECTED PROCEDURE cErrorMessage_Assign
		LPARAMETERS tcErrorMessage
		IF VARTYPE(tcErrorMessage) <> [C]
			THIS.SetError([Invalid datatype for ] + STRTRAN(PROGRAM(), [_ASSIGN], []) + [ property.])
			RETURN .f.
		ENDIF
		THIS.cErrorMessage = ALLTRIM(tcErrorMessage)
	ENDPROC
ENDDEFINE
